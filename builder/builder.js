const fs = require('fs')
const types = require('./types')

types.forEach((type) => {
  // typeName: 'InputRepo'
  // fnArgs: null
  // children: {
  //   'issues': 'InputRepoIssues'
  //   'git': 'InputGit'
  // }
  // verbs:
  //   fetch:
  //     fnArgs: []
  //     resultType: 'RepoResponse'
  //   remove:
  //     fnArgs: []
  //     resultType: 'void'


  const importTypes = {}

  const instanceChildren = []
  const instanceChildrenInterfaceDeclarations = []
  const instanceChildrenDeclarations = []
  Object.keys(type.children || {}).forEach((instanceChildName) => {
    const instanceChildType = type.children[instanceChildName]
    importTypes[instanceChildType] = true
    instanceChildren.push(`this.${instanceChildName} = new ${instanceChildType}(basePath + '/${instanceChildName}')`)
    instanceChildrenInterfaceDeclarations.push(`${instanceChildName} : I${instanceChildType}`)
    instanceChildrenDeclarations.push(`${instanceChildName} : ${instanceChildType}(basePath + '/${instanceChildName}')`)
  })

  const verbMethods = []
  const verbMethodInterfaces = []
  Object.keys(type.verbs || {}).forEach((verbMethodKey) => {
    const {fnArgs, resultType} = type.verbs[verbMethodKey]
    importTypes[resultType.replace('[]', '')] = true // Strip off arrays
    const resultTypeNoVoid = resultType === 'void' ? 'void' : `I${resultType}`
    verbMethodInterfaces.push(`${verbMethodKey}(/*args*/) : Promise<${resultTypeNoVoid}>`)
    verbMethods.push(`${verbMethodKey}(/*args*/) : Promise<${resultTypeNoVoid}> { return VERBS._${verbMethodKey}<${resultTypeNoVoid}>(basePath) }`)
  })

  const instanceMethodsStr = '/* Not implemented yet */'


  let functionArgsAndReturn = ''

  if (type.returnType) {
    importTypes[type.returnType] = true

    let index = 1
    const args = []
    type.fnArgs.forEach(({type}) => {
      args.push(`arg${index}: ${type}`)
      index += 1
    })

    functionArgsAndReturn = `(${args.join(', ')}): I${type.returnType}`
  }

  const instanceRequires = Object.keys(importTypes)
  .filter((importType) => importType != 'void') // remove the void type
  .map((importType) => `import {I${importType}, ${importType}} from './${importType}'`)

  let source = `
// This file is autogenerated
import * as VERBS from '../verbs'
${instanceRequires.join('\n')}

export interface I${type.typeName} {
  ${functionArgsAndReturn}

  ${instanceChildrenInterfaceDeclarations.join('\n')}

  ${verbMethodInterfaces.join('\n')}
}
  `


  let functionDefinition = ''
  if (type.returnType) {
    // Cannot just create a simple class. Need to create a function and then Object.merge the props onto it
    // http://stackoverflow.com/a/41853194 in https://stackoverflow.com/questions/12766528/build-a-function-object-with-properties-in-typescript#18640025

    let index = 1
    const args = []
    const pathExpander = []
    type.fnArgs.forEach(({type}) => {
      args.push(`arg${index}: ${type}`)
      pathExpander.push(`arg${index}`)
      index += 1
    })


    functionDefinition = `
(${args.join(', ')}) => {
  return ${type.returnType}(basePath + '/' + ${pathExpander.join(" + '/' + ")})
},
    `

  }
//     // Create a simple class
//     source += `
// export class ${type.typeName} {
//    _basePath: string
//    ${instanceChildrenInterfaceDeclarations.join('\n')}
//    constructor(basePath : string) {
//      this._basePath = basePath
//      ${instanceChildren.join('\n')}
//    }
//
//    ${instanceMethodsStr}
//
//    ${verbMethods.join('\n')}
// }
// `


  source += `
export const ${type.typeName} = (basePath : string): I${type.typeName} => {
  return Object.assign(
    ${functionDefinition}
    {
      ${instanceChildrenDeclarations.concat(verbMethods).join(',\n')}
    }
  )
}
`




  fs.writeFileSync(`${__dirname}/generated-ts/${type.typeName}.ts`, source)
})
